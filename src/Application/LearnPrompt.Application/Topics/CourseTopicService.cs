using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using LearnPrompt.Application.Repositories;
using LearnPrompt.Domain.Constants;
using LearnPrompt.Domain.Entities;

namespace LearnPrompt.Application.Topics
{
    public class CourseTopicService : ICourseTopicService
    {
        private readonly ICourseRepository _courseRepository;
        private readonly ITopicExtractionService _topicExtractionService;

        public CourseTopicService(
            ICourseRepository courseRepository,
            ITopicExtractionService topicExtractionService)
        {
            _courseRepository = courseRepository;
            _topicExtractionService = topicExtractionService;
        }

        public async Task<Course> GetCourseWithTopicsAsync(int courseId, string ownerId, CancellationToken cancellationToken = default)
        {
            var course = await _courseRepository.GetByIdAsync(courseId)
                ?? throw new KeyNotFoundException("Course not found.");

            if (!string.Equals(course.OwnerId, ownerId, StringComparison.Ordinal))
            {
                throw new UnauthorizedAccessException();
            }

            var orderedTopics = course.CourseTopics
                .OrderByDescending(t => t.IsSelected)
                .ThenBy(t => t.Source)
                .ThenBy(t => t.Title, StringComparer.CurrentCultureIgnoreCase)
                .ToList();

            course.CourseTopics = orderedTopics;

            return course;
        }

        public async Task<IReadOnlyList<CourseTopic>> GenerateTopicsAsync(int courseId, string ownerId, CancellationToken cancellationToken = default)
        {
            var course = await GetCourseWithTopicsAsync(courseId, ownerId, cancellationToken);
            var chunks = await _courseRepository.GetChunksByCourseIdAsync(courseId);

            if (chunks.Count == 0)
            {
                return Array.Empty<CourseTopic>();
            }

            var suggestions = await _topicExtractionService.ExtractTopicsAsync(course, chunks, cancellationToken);
            if (suggestions.Count == 0)
            {
                return course.CourseTopics.ToList();
            }

            var existingTopics = await _courseRepository.GetTopicsByCourseIdAsync(courseId);
            var manualTitles = existingTopics
                .Where(t => t.Source == TopicSource.Manual)
                .Select(t => t.Title)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            var autoTopics = existingTopics
                .Where(t => t.Source == TopicSource.AutoGenerated)
                .ToList();

            if (autoTopics.Count > 0)
            {
                _courseRepository.RemoveTopics(autoTopics);
            }

            var now = DateTime.UtcNow;
            var distinctTitles = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var newTopics = new List<CourseTopic>();

            foreach (var suggestion in suggestions)
            {
                if (string.IsNullOrWhiteSpace(suggestion.Title))
                {
                    continue;
                }

                var title = suggestion.Title.Trim();
                if (title.Length == 0 || title.Length > 200)
                {
                    continue;
                }

                if (manualTitles.Contains(title) || !distinctTitles.Add(title))
                {
                    continue;
                }

                double? confidence = null;
                if (!double.IsNaN(suggestion.Confidence) && suggestion.Confidence >= 0 && suggestion.Confidence <= 1)
                {
                    confidence = Math.Round(suggestion.Confidence, 3);
                }

                newTopics.Add(new CourseTopic
                {
                    CourseId = courseId,
                    Title = title,
                    Source = TopicSource.AutoGenerated,
                    IsSelected = false,
                    Confidence = confidence,
                    CreatedAt = now
                });
            }

            if (newTopics.Count > 0)
            {
                await _courseRepository.AddTopicsAsync(newTopics);
            }

            await _courseRepository.SaveChangesAsync();

            return await _courseRepository.GetTopicsByCourseIdAsync(courseId);
        }

        public async Task<CourseTopic> CreateManualTopicAsync(int courseId, string ownerId, string title, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(title))
            {
                throw new ArgumentException("Topic title is required.", nameof(title));
            }

            var normalizedTitle = title.Trim();
            if (normalizedTitle.Length > 200)
            {
                normalizedTitle = normalizedTitle[..200];
            }

            var course = await GetCourseWithTopicsAsync(courseId, ownerId, cancellationToken);
            if (course.CourseTopics.Any(t => string.Equals(t.Title, normalizedTitle, StringComparison.OrdinalIgnoreCase)))
            {
                throw new InvalidOperationException("A topic with the same title already exists.");
            }

            var topic = new CourseTopic
            {
                CourseId = courseId,
                Title = normalizedTitle,
                Source = TopicSource.Manual,
                IsSelected = true,
                CreatedAt = DateTime.UtcNow
            };

            await _courseRepository.AddTopicsAsync(new[] { topic });
            await _courseRepository.SaveChangesAsync();

            return topic;
        }

        public async Task<CourseTopic> SetTopicSelectionAsync(int topicId, string ownerId, bool isSelected, CancellationToken cancellationToken = default)
        {
            var topic = await _courseRepository.GetTopicByIdAsync(topicId)
                ?? throw new KeyNotFoundException("Topic not found.");

            if (!string.Equals(topic.Course.OwnerId, ownerId, StringComparison.Ordinal))
            {
                throw new UnauthorizedAccessException();
            }

            topic.IsSelected = isSelected;
            await _courseRepository.SaveChangesAsync();
            return topic;
        }

        public async Task DeleteTopicAsync(int topicId, string ownerId, CancellationToken cancellationToken = default)
        {
            var topic = await _courseRepository.GetTopicByIdAsync(topicId)
                ?? throw new KeyNotFoundException("Topic not found.");

            if (!string.Equals(topic.Course.OwnerId, ownerId, StringComparison.Ordinal))
            {
                throw new UnauthorizedAccessException();
            }

            if (!topic.IsManual)
            {
                throw new InvalidOperationException("Only manually created topics can be deleted.");
            }

            await _courseRepository.RemoveTopicAsync(topic);
            await _courseRepository.SaveChangesAsync();
        }
    }
}

